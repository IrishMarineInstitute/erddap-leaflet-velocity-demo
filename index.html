<html> 
	<head>
		 <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" integrity="sha512-xodZBNTC5n17Xt2atTPuE1HxjVMSvLVW9ocqUKLsCC5CXdbqCmblAshOMAS6/keqq/sMZMZ19scR4PsZChSR7A==" crossorigin="" />
		 <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js" integrity="sha512-XQoYMqMTK8LvdxXYG3nZ448hOEQiglfqkJs1NOQV44cWnUrBc8PkAOcXy20w0vlaXaVUearIOBhiXZ5V3ynxwA==" crossorigin=""></script>
		 
		 <link rel="stylesheet" href="https://danwild.github.io/leaflet-velocity/dist/leaflet-velocity.min.css" />
		 <script src="https://danwild.github.io/leaflet-velocity/dist/leaflet-velocity.js" crossorigin=""></script>
		 
		 <style>
		 	#map{height: 100%}
		 </style>
	</head>
	<body>
		<p id="err"></p>
		<div id="map"></div>
		<script type="text/javascript">
		
	const erddapBaseUrl = 'https://erddap.marine.ie';
	const datasetID = 'IMI_Model_Stats';
	const uParameter = 'sea_surface_x_velocity';
	const vParameter = 'sea_surface_y_velocity';
	const minLat = 48.5;
	const maxLat = 58.5;
	const minLon = -17.0;
	const maxLon = -2.0;
	const refTime = '2019-12-15T00:00:00Z';
	const strideLon = 20;
	const strideLat = 20;
	
	var mymap = L.map('map').setView([maxLat-((maxLat-minLat)/2), maxLon-((maxLon-minLon)/2)], 5);
	var Esri_DarkGreyCanvas = L.tileLayer(
			"https://{s}.sm.mapstack.stamen.com/" +
			"(toner-lite,$fff[difference],$fff[@23],$fff[hsl-saturation@20])/" +
			"{z}/{x}/{y}.png",
			{
				attribution: 'Tiles &copy; Esri &mdash; Esri, DeLorme, NAVTEQ, TomTom, Intermap, iPC, USGS, FAO, ' +
				'NPS, NRCAN, GeoBase, Kadaster NL, Ordnance Survey, Esri Japan, METI, Esri China (Hong Kong), and the GIS User Community'
			}
		).addTo(mymap);
	
	
	fetch(
		erddapBaseUrl 
			+ '/erddap/griddap/' 
			+ datasetID 
			+ '.json?' 
			+ uParameter + '[(' + refTime + '):1:(' + refTime + ')][(' +  String(minLat) + '):' + String(strideLat) + ':(' + String(maxLat) + ')][(' + String(minLon) + '):'+ String(strideLon) +':(' + String(maxLon) + ')],' 
			+ vParameter + '[(' + refTime + '):1:(' + refTime + ')][(' + String(minLat) + '):' + String(strideLat)+ ':(' + String(maxLat) + ')][(' + String(minLon) + '):' + String(strideLon) + ':(' + String(maxLon) + ')]').
	then(
		response => response.json()
	).
	then(
		data => [{
			'header':{
				'la1': Math.max(...Array.from([...new Set(data.table.rows.map(x => x[1]))])),
				'la2': Math.min(...Array.from([...new Set(data.table.rows.map(x => x[1]))])),
				'lo1': Math.min(...Array.from([...new Set(data.table.rows.map(x => x[2]))])),
				'lo2': Math.max(...Array.from([...new Set(data.table.rows.map(x => x[2]))])),
				'dx': (Math.max(...Array.from([...new Set(data.table.rows.map(x => x[2]))])) - Math.min(...Array.from([...new Set(data.table.rows.map(x => x[2]))]))) / ([...new Set(data.table.rows.map(x => x[2]))].length - 1),
				'dy': (Math.max(...Array.from([...new Set(data.table.rows.map(x => x[1]))])) - Math.min(...Array.from([...new Set(data.table.rows.map(x => x[1]))]))) / ([...new Set(data.table.rows.map(x => x[1]))].length - 1),
				'nx': [...new Set(data.table.rows.map(x => x[2]))].length,
				'ny': [...new Set(data.table.rows.map(x => x[1]))].length,
				'parameterCategory': 2,
				'parameterNumber': 2,
				'parameterUnit': 'm.s-1',
				'parameterNumberName': data.table.columnNames[3],
				'refTime': refTime.replace('T', ' ').replace('Z','')
			}, 
			'data': data.table.rows.sort((a,b) => b[1]-a[1]).map(x => x[3])
		},{
			'header':{
				'la1': Math.max(...Array.from([...new Set(data.table.rows.map(x => x[1]))])),
				'la2': Math.min(...Array.from([...new Set(data.table.rows.map(x => x[1]))])),
				'lo1': Math.min(...Array.from([...new Set(data.table.rows.map(x => x[2]))])),
				'lo2': Math.max(...Array.from([...new Set(data.table.rows.map(x => x[2]))])),
				'dx': (Math.max(...Array.from([...new Set(data.table.rows.map(x => x[2]))])) - Math.min(...Array.from([...new Set(data.table.rows.map(x => x[2]))]))) / ([...new Set(data.table.rows.map(x => x[2]))].length - 1),
				'dy': (Math.max(...Array.from([...new Set(data.table.rows.map(x => x[1]))])) - Math.min(...Array.from([...new Set(data.table.rows.map(x => x[1]))]))) / ([...new Set(data.table.rows.map(x => x[1]))].length - 1),
				'nx': [...new Set(data.table.rows.map(x => x[2]))].length,
				'ny': [...new Set(data.table.rows.map(x => x[1]))].length,
				'parameterCategory': 2,
				'parameterNumber': 3,
				'parameterUnit': 'm.s-1',
				'parameterNumberName': data.table.columnNames[4],
				'refTime': refTime.replace('T', ' ').replace('Z','')
			}, 
			'data': data.table.rows.sort((a,b) => b[1]-a[1]).map(x => x[4])
		}]
	).then(
	report => {
			try{
			var velocityLayer = L.velocityLayer({
				displayValues: true,
				displayOptions: {
					velocityType: "GBR Water",
					displayPosition: "bottomleft",
					displayEmptyString: "No water data"
				},
				data: report,
				maxVelocity: 1,
				minVelocity: 0,
				velocityScale: 0.1,
				opacity: 0.97
			}).addTo(mymap);
			console.log(report);
		} catch(err) {
			console.log(err.message);
		}
	}
)
		</script>
	</body>
</html>
